/// <reference path="Game.d.ts" />
module Phaser {
    class GameMath {
        constructor(game: Game);
        private _game;
        static PI: number;
        static PI_2: number;
        static PI_4: number;
        static PI_8: number;
        static PI_16: number;
        static TWO_PI: number;
        static THREE_PI_2: number;
        static E: number;
        static LN10: number;
        static LN2: number;
        static LOG10E: number;
        static LOG2E: number;
        static SQRT1_2: number;
        static SQRT2: number;
        static DEG_TO_RAD: number;
        static RAD_TO_DEG: number;
        static B_16: number;
        static B_31: number;
        static B_32: number;
        static B_48: number;
        static B_53: number;
        static B_64: number;
        static ONE_THIRD: number;
        static TWO_THIRDS: number;
        static ONE_SIXTH: number;
        static COS_PI_3: number;
        static SIN_2PI_3: number;
        static CIRCLE_ALPHA: number;
        static ON: bool;
        static OFF: bool;
        static SHORT_EPSILON: number;
        static PERC_EPSILON: number;
        static EPSILON: number;
        static LONG_EPSILON: number;
        public cosTable: any[];
        public sinTable: any[];
        public fuzzyEqual(a: number, b: number, epsilon?: number): bool;
        public fuzzyLessThan(a: number, b: number, epsilon?: number): bool;
        public fuzzyGreaterThan(a: number, b: number, epsilon?: number): bool;
        public fuzzyCeil(val: number, epsilon?: number): number;
        public fuzzyFloor(val: number, epsilon?: number): number;
        public average(...args: any[]): number;
        public slam(value: number, target: number, epsilon?: number): number;
        public percentageMinMax(val: number, max: number, min?: number): number;
        public sign(n: number): number;
        public truncate(n: number): number;
        public shear(n: number): number;
        public wrap(val: number, max: number, min?: number): number;
        public arithWrap(value: number, max: number, min?: number): number;
        public clamp(input: number, max: number, min?: number): number;
        public snapTo(input: number, gap: number, start?: number): number;
        public snapToFloor(input: number, gap: number, start?: number): number;
        public snapToCeil(input: number, gap: number, start?: number): number;
        public snapToInArray(input: number, arr: number[], sort?: bool): number;
        public roundTo(value: number, place?: number, base?: number): number;
        public floorTo(value: number, place?: number, base?: number): number;
        public ceilTo(value: number, place?: number, base?: number): number;
        public interpolateFloat(a: number, b: number, weight: number): number;
        public radiansToDegrees(angle: number): number;
        public degreesToRadians(angle: number): number;
        public angleBetween(x1: number, y1: number, x2: number, y2: number): number;
        public normalizeAngle(angle: number, radians?: bool): number;
        public nearestAngleBetween(a1: number, a2: number, radians?: bool): number;
        public normalizeAngleToAnother(dep: number, ind: number, radians?: bool): number;
        public normalizeAngleAfterAnother(dep: number, ind: number, radians?: bool): number;
        public normalizeAngleBeforeAnother(dep: number, ind: number, radians?: bool): number;
        public interpolateAngles(a1: number, a2: number, weight: number, radians?: bool, ease?): number;
        public logBaseOf(value: number, base: number): number;
        public GCD(m: number, n: number): number;
        public LCM(m: number, n: number): number;
        public factorial(value: number): number;
        public gammaFunction(value: number): number;
        public fallingFactorial(base: number, exp: number): number;
        public risingFactorial(base: number, exp: number): number;
        public binCoef(n: number, k: number): number;
        public risingBinCoef(n: number, k: number): number;
        public chanceRoll(chance?: number): bool;
        public maxAdd(value: number, amount: number, max: number): number;
        public minSub(value: number, amount: number, min: number): number;
        public wrapValue(value: number, amount: number, max: number): number;
        public randomSign(): number;
        public isOdd(n: number): bool;
        public isEven(n: number): bool;
        public wrapAngle(angle: number): number;
        public angleLimit(angle: number, min: number, max: number): number;
        public linearInterpolation(v, k);
        public bezierInterpolation(v, k): number;
        public catmullRomInterpolation(v, k);
        public linear(p0, p1, t);
        public bernstein(n, i): number;
        public catmullRom(p0, p1, p2, p3, t);
        public difference(a: number, b: number): number;
        public globalSeed: number;
        public random(): number;
        public srand(Seed: number): number;
        public getRandom(Objects, StartIndex?: number, Length?: number);
        public floor(Value: number): number;
        public ceil(Value: number): number;
        public sinCosGenerator(length: number, sinAmplitude?: number, cosAmplitude?: number, frequency?: number): any[];
        public shiftSinTable(): number;
        public shiftCosTable(): number;
        public vectorLength(dx: number, dy: number): number;
        public dotProduct(ax: number, ay: number, bx: number, by: number): number;
    }
}
